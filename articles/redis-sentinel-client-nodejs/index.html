<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width"><title>Building a Redis Sentinel Client for Node.js - DocuSign Dev Blog</title><link rel="alternate" href="undefined/feed.xml" type="application/rss+xml" title="Brought to you by the development teams at DocuSign"><link rel="stylesheet" href="/assets/css/bootstrap.min.css"><link rel="stylesheet" href="/assets/css/syntax.css"><link href="//fonts.googleapis.com/css?family=Inconsolata:400,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/assets/css/devblog.css"><link rel="icon" href="/favicon.ico"><link rel="shortcut icon" type="image/x-icon" href="/assets/img/favicon/docusigndev-favicon-32.png"><link rel="apple-touch-icon" sizes="114×114" href="/assets/img/favicon/docusigndev-favicon-114.png"><link rel="apple-touch-icon" sizes="72×72" href="/assets/img/favicon/docusigndev-favicon-72.png"><link rel="apple-touch-icon" href="/assets/img/favicon/docusigndev-favicon-57.png"><link rel="apple-touch-icon" sizes="512x512" href="/assets/img/favicon/docusigndev-favicon-512.png"></head><body class="article-detail"><div class="container"><header id="top-header" class="row"><div class="col-sm-12"><h1><a href="/">DocuSign Dev Blog</a></h1><h2>Brought to you by the development teams at DocuSign</h2></div></header><div class="row"><div id="left-col" class="col-sm-3 col-md-2"><nav><ul class="row"><li class="col-sm-12"><a href="/contributors/">Contributors</a></li><li class="col-sm-12"><a href="http://github.com/docusigndev">Code</a></li><li class="col-sm-12"><a href="https://twitter.com/docusigndev">Follow</a></li><li class="col-sm-12"><a href="http://www.docusign.com">DocuSign.com</a></li></ul></nav><section class="row about-author"><div class="col-sm-12"><a href="/contributors/ben-buckman/" class="author-name">Ben Buckman</a></div><div class="col-xs-4 col-sm-12"><div class="author-pic"><a href="/contributors/ben-buckman/"><img alt="Ben Buckman" src="/assets/img/ben-buckman.jpg"></a></div></div><div class="col-xs-6 col-sm-12"><div class="author-blurb">Lead Engineer / Scrum Lead</div><div class="author-twitter">Twitter:
&nbsp;<a href="http://twitter.com/thebuckst0p">@thebuckst0p</a></div><div class="author-github">Github:
&nbsp;<a href="http://github.com/benbuckman">benbuckman</a></div></div></section><section class="tags"><ul><li><a href="/topic/nodejs/">nodejs</a></li><li><a href="/topic/redis/">redis</a></li></ul></section></div><main id="right-col" class="col-sm-8 col-sm-offset-1 col-md-9"><div class="article-meta"><div class="date">13 November 2013</div></div><h1>Building a Redis Sentinel Client for Node.js</h1><article><section class="content"><p>We use <a href="http://redis.io/">Redis</a> for sessions and for a short-lived data cache in our <a href="http://nodejs.org/">node.js</a> application.
Like any component in the system, there’s a potential risk of failure, and graceful failover to a “slave” instance is a way to mitigate the impact. We use <a href="http://redis.io/topics/sentinel"><strong>Redis Sentinel</strong></a> to help manage this failover&nbsp;process.</p>
<p>As the <a href="http://redis.io/topics/sentinel">docs</a> describe,</p>
<blockquote>
<p>Redis Sentinel is a <strong>distributed system</strong>, this means that usually you want to run multiple Sentinel processes across your infrastructure, and this processes will use agreement protocols in order to understand if a master is down and to perform the&nbsp;failover.</p>
</blockquote>
<p>Essentially, each node server has its own sentinel corresponding to each redis cluster [master and slave(s)] that it connects to. We have one redis cluster, so <strong>for N node servers, there are N sentinels</strong>. (This isn’t the only way to do it - there could be only one sentinel, or any other configuration really, but the 1:1 ratio seems to be the simplest.) Each sentinel is connected to the master and slaves to monitor their availability, as well as to the other sentinels. If the master goes down, the sentinels establish a “quorum” and agree on which slave to promote to master. They communicate this through their own pub/sub&nbsp;channels.</p>
<p><strong>The sentinel is not a proxy</strong> - the connection to the sentinel doesn’t <em>replace</em> the connecton to the master - it’s a separate instance with the sole purpose of managing master/slave availability. So the app connects to the sentinel in parallel with the master connection, and listens to the chatter on the sentinel channels to know when a failover occurred. It then has to manage the reconnection to the new master on its&nbsp;own.</p>
<p><a href="/articles/redis-sentinel-client-nodejs/redis-sentinel-diagram.pdf"><img src="/articles/redis-sentinel-client-nodejs/redis-sentinel-diagram.png" alt="Redis Sentinel Client flow diagram"></a></p>
<p>We’re using the standard <a href="https://github.com/mranney/node_redis">node_redis</a> library, which is robust, easy to use, and works “out of the box” for things like <a href="https://github.com/visionmedia/connect-redis">sessions</a>. But a year ago, when Sentinel started to gain adoption, the best approach for adding <a href="https://github.com/mranney/node_redis/issues/302"><strong>Sentinel awareness</strong></a> to node_redis clients wasn’t clear, so a thread started on Github to <a href="https://github.com/mranney/node_redis/issues/302">figure it&nbsp;out</a>.</p>
<p>One simple approach was for the application to simply hold two connections, for sentinel and master, and when the sentinel reports a failover, to reconnect the master. But the way node_redis works, any <strong>data in transit during the failover is lost</strong>. Also with this approach, the code listening to the Sentinel’s pub/sub chatter lived in the application, and wasn’t as <strong>encapsulated</strong> as we thought it should&nbsp;be.</p>
<p>So we decided to create a middle tier, a <strong>redis sentinel client</strong>, that would handle all this automatically.
<span class="more"></span>
The goals&nbsp;were:</p>
<ol>
<li><strong>Transparent, drop-in replacement</strong> for a <a href="https://github.com/mranney/node_redis">node_redis</a> client, handling connections to master, slave(s), and sentinel in the&nbsp;background.</li>
<li><strong>Handles all RedisClient commands</strong> (including&nbsp;pub/sub).</li>
<li><strong>No data loss</strong> during&nbsp;failover.</li>
</ol>
<p>The result - still a work in progress - is the <a href="https://github.com/DocuSignDev/node-redis-sentinel-client"><strong>node-redis-sentinel-client</strong></a> module. Initially we added it into a fork of node_redis itself, then we split it into its own <a href="https://npmjs.org/package/redis-sentinel-client">module</a>, but still dependent on <a href="https://github.com/DocuSignDev/node_redis">our fork</a> to export shared components and fix the data loss&nbsp;problem.</p>
<p>The <code>RedisSentinelClient</code> object holds three sub-clients (each a normal <code>RedisClient</code> object): an <code>activeMasterClient</code> which connects to the current master, a <code>sentinelTalker</code> to read from the Sentinel, and a <code>sentinelListener</code> to listen for failovers (because in node_redis’ pubsub mode, a client can only pub <em>or</em> sub, not both.) All commands get proxied to the <code>activeMasterClient</code>, and that client is reconnected to the new master after a&nbsp;failover.</p>
<p>This has worked pretty well so far, including in production. We’ve never actually had a Redis failover in production, fortunately, but in all our tests, the client behaves well: the node processes temporarily lose connectivity, but once the failover completes, they resume gracefully with no data&nbsp;loss.</p>
<p>There are still a few questions and problems with our solution, however:</p>
<p>First, when the <code>RedisSentinelClient</code> is first instantiated, if it can’t immediately connect, it doesn’t handle it very well. This is because of the way the <code>activeMasterClient</code> is first set up, and a simple fix has been elusive. (It becomes “stable” only after this initial&nbsp;connection.)</p>
<p>Second, this middle-tier solution <strong>might ultimately be too heavy</strong>. Our Redis data is considered volatile: since it’s only for sessions and temporary caching, data loss is at worst a nuisance. So all the effort put into buffering data during a failover might be unnecessary. (On the other hand, Redis supports disk backup, and not every implementation is for volatile data, so a general-purpose solution could err on the side of&nbsp;robustness.)</p>
<p>Third, the changes in our <a href="https://github.com/DocuSignDev/node_redis">fork</a> to <a href="https://github.com/mranney/node_redis">node_redis</a> (submitted as two <a href="https://github.com/mranney/node_redis/pull/428">pull</a> <a href="https://github.com/mranney/node_redis/pull/429">requests</a>) haven’t been accepted, probably because there still isn’t consensus on the right approach. It’s also possible (and a little surprising) that Sentinel itself hasn’t fully caught on. (Surprising because it solves a real problem very nicely, and lacks strong&nbsp;alternatives.)</p>
<p><strong>Do you use Redis Sentinel with node? How do you do it?</strong> We’d love to hear about your experience or ideas in the&nbsp;comments.</p>
<div class="share-box"><div id="fb-button" data-href="http://engineering.docusign.com/articles/redis-sentinel-client-nodejs/" data-type="button_count" style="width:auto !important;" class="fb-share-button"></div><div id="fb-root"><script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=221822221222506";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><a id="twtr-button" href="https://twitter.com/share" data-url="http://engineering.docusign.com/articles/redis-sentinel-client-nodejs/" data-via="docusigndev" class="twitter-share-button">Tweet<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
</script></a></div></section></article><section class="article-links"><ul class="pager"><li><a href="/articles/custom-scalable-css-radio-buttons/">&laquo; Custom Scalable CSS Radio Buttons</a></li><li><a href="/articles/docusign-hackathon-2013/">Hackathon! &raquo;</a></li></ul></section><section class="article-comments"><div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'docusigndev';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section></main></div><footer class="row"></footer></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-38381866-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></body></html>